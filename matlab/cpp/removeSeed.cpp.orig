#include <set>
#include <mex.h>
#include <matrix.h>

#ifndef ADDSEED_H
#define ADDSEED_H
#include "addSeed.h"
#endif

#ifndef SKIZEXCEPTION_H
#define SKIZEXCEPTION_H
#include "skizException.h"
#endif

#ifndef NSSTAR_H
#define NSSTAR_H
#include "NSStar.h"
#endif

#ifndef POINTINREGION_H
#define POINTINREGION_H
#include "pointInRegion.h"
#endif

#ifndef GETREGION_H
#define GETREGION_H
#include "getRegion.h"
#endif

#ifndef AUX_H
#define AUX_H
#include "aux.h"
#endif

#ifndef INF
#define INF std::numeric_limits<real>::infinity()
#endif

#ifndef TYPEDEFS
#define TYPEDEFS
typedef double real;
typedef std::vector<real> RealVec;
typedef Eigen::Array<real, Eigen::Dynamic, Eigen::Dynamic> Mat;
#endif

#include "removeSeed.h"


bool removeSeed(vd &VD, mwIndex Sk) {

    VD.k += 1;
    Mat bounds = getRegion(VD, Sk);

    RealVec Ns = VD.Nk.at(Sk);
    bool finish = false;
    for (int j = 0; j < bounds.rows(); ++j) {
        if (bounds(j, 0) == -1) {
            if (finish) {
                break;
            } else {
                continue;
            }
        }

        finish = true;
        real lb = std::max(1.0, bounds(j, 0) - 1);
        real ub = std::min(VD.nc, bounds(j, 1));
        for (real i = lb; i < ub; ++i) {
            std::array<real, 2> pt = {(real) i + 1, (real) j + 1};
            Mat distances(Ns.size(), 2);
            distances.setZero();
            for (auto idx=0; idx<Ns.size(); ++idx){
                mwIndex r = Ns.at(idx);
                distances(idx, 0) = r;
                distances(idx, 1) = sqDist(i+1, j+1, VD.Sx[r], VD.Sy[r]);
            }
            Mat::Index argmin, maxCol;
            mwIndex min = distances.col(1).minCoeff(&argmin);
            VD.Vk.lam(j, i) = distances(argmin, 0);
            VD.Vk.v(j, i) = (distances.col(1) == min).count() == 1 ? 0 : 1;
            /*if(VD.Vk.v(j, i) == 1){
                for(auto k=0; k<Ns.size(); ++k){
                    if(distances(k, 1) == min) {
                    }
                }
            }*/
        }
    }

    std::map<real, RealVec> newDict;
    for (mwIndex r : VD.Nk.at(Sk)) {
        RealVec Ns = VD.Nk.at(r);
        Ns.erase(std::remove(Ns.begin(), Ns.end(), Sk), Ns.end());
        newDict[r] = Ns;
    }

    for (mwIndex s : VD.Nk.at(Sk)) {
        if(s == Sk){
            continue;
        }
        RealVec A = VD.Nk.at(s);
        A.insert(A.end(), VD.Nk.at(Sk).begin(), VD.Nk.at(Sk).end());
        A.erase(std::remove(A.begin(), A.end(), s), A.end());
        A.erase(std::remove(A.begin(), A.end(), Sk), A.end());
        for (mwIndex r : VD.Nk.at(Sk)) {
            if (r == Sk || r == s || inVector(VD.Nk.at(s), r)) {
                continue;
            }
            for(int u : A){
                if(u == r){
                    continue;
                }

                std::array<real, 2> cc = { -1, -1 };
                try{
                    cc = circumcentre(VD.Sx.at(s), VD.Sy.at(s), VD.Sx.at(r),
                                                            VD.Sy.at(r), VD.Sx.at(u), VD.Sy.at(u));
                } catch (SKIZLinearSeedsException &e) {
                    continue;
                }
                if(pointInRegion(VD, cc, s, A)){
                    updateDict(newDict, s, r);
                    updateDict(newDict, r, s);
                    break;
                }
            }
        }
    }

    for(auto i : newDict){
        VD.Nk.at(i.first) = i.second;
    }

    VD.Sk.erase((real)Sk);

    return false;
}