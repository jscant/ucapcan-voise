/**
 * @file
 * @brief Small, useful auxilliary functions
*/
#ifdef MATLAB_MEX_FILE
#include <mex.h>
#include <matrix.h>
#endif
#include <algorithm>
#include <array>
#include <vector>
#include <map>
#include <fstream>

#include "aux.h"
#include "skizException.h"

/**
 * @defgroup sqDist sqDist
 * @ingroup sqDist
 * @{
 * @brief Finds the squared difference between two points
 * @param p1,p2 x and y coordinates of first point
 * @param q1,q2 x and y coordinates of second point
 * @returns Squared distance between points p and q
 *
 * Using squared distance gives integer results when inputs are limited to W as defined in doi: 10.1109/34.625128,
 * Section 2.2 which avoids floating point precision errors.
 */
// Use square distance where possible to avoid floating point precision problems
real sqDist(const real &p1, const real &p2, const real &q1, const real &q2) {
    return (pow((p1 - q1), 2) + pow((p2 - q2), 2));
}
/// @}

/**
 * @defgroup circumcentre circumcentre
 * @ingroup circumcentre
 * @{
 * @brief Finds the cirumcentre of the triangle formed by three given points
 * @param ax,ay x and y coordinates of first vertex
 * @param bx,by x and y coordinates of second vertex
 * @param cx,cy x and y coordinates of third vertex
 * @returns Circumcentre of points a, b and c
 *
 * The cirumcentre of a triangle is the unique point in \f$R^2\f$ that is equidistant from its three vertices. This is the
 * equivalent of X(a, b, c) as defined in Section 2 of reference [1].
 */
std::array<real, 2> circumcentre(const real &ax, const real &ay, const real &bx, const real &by, const real &cx,
                                 const real &cy) {

    std::array<real, 2> result;
    real D = 2 * ((ax * (by - cy) + bx * (cy - ay) + cx * (ay - by)));
    if (D == 0) {
        // Message only for debugging, this is expected behaviour as cc does not exist, so cannot be 'within' any region
        std::string msg = "Collinear points:\n(" + std::to_string(ax) + ", " + std::to_string(ay) + ")\n" +
                          std::to_string(bx) + ", " + std::to_string(by) + ")\n" +
                          std::to_string(cx) + ", " + std::to_string(cy) + ")\n";
        throw SKIZLinearSeedsException(msg.c_str());
    }
    real Ux = ((pow(ax, 2) + pow(ay, 2)) * (by - cy) + (pow(bx, 2) + pow(by, 2)) * (cy - ay) +
               (pow(cx, 2) + pow(cy, 2)) * (ay - by)) / D;
    real Uy = ((pow(ax, 2) + pow(ay, 2)) * (cx - bx) + (pow(bx, 2) + pow(by, 2)) * (ax - cx) +
               (pow(cx, 2) + pow(cy, 2)) * (bx - ax)) / D;
    result.at(0) = Ux;
    result.at(1) = Uy;
    return result;
}
/// @}

/**
 * @defgroup inVector inVector
 * @ingroup inVector
 * @{
 * @brief Checks whether or not item is in vector.
 * @param vec Vector to be checked for item
 * @param item Item to be looked for
 * @returns true: item is in vector
 * @returns false: item is not in vector
 *
 */
bool inVector(const RealVec &vec, const real &item) {
    if (vec.size() < 1) {
        return false;
    }
    if (std::find(vec.begin(), vec.end(), item) != vec.end()) {
        return true;
    }
    return false;
}
/// @}

/**
 * @defgroup updateDict updateDict
 * @ingroup updateDict
 * @{
 * @brief Custom routine for adding to the vector in a dictionary of vectors only if the item does not already exist
 * @param d Dictionary
 * @param key Key to be added
 * @param value Value to be added to vector
 */

// Adds value to dictionary ONLY if it does not already exist.
void updateDict(std::map<real, RealVec> &d, const real &key, const real &value) {
    /// If key and corresponding vector do not exist, we create both and populate vector with value
    try{
        d.at(key);
    } catch (std::out_of_range &e){
        d[key] = RealVec();
        d.at(key).push_back(value);
        return;
    }
    if (!inVector(d.at(key), value)) {
        d.at(key).push_back(value);
    }
}
/// @}

/**
 * @defgroup readSeeds readSeeds
 * @ingroup readSeeds
 * @{
 * @brief Reads seeds from ascii-formatted files generated by Matlab's 'save' function.
 * @param filename Name of text file to be read
 * @returns Vector containing two std::vector<double>: the x and y coordinates of the seeds
 */
std::vector<RealVec> readSeeds(std::string filename) {
    std::ifstream afile;
    afile.open(filename.c_str());
    RealVec Sx;
    RealVec Sy;
    uint32 x = 0;
    real number;
    while(afile >> number){
        if(x % 2 == 0){
            Sx.push_back(number);
        } else {
            Sy.push_back(number);
        }
        x += 1;
    }
    std::vector<RealVec> result;
    result.push_back(Sx);
    result.push_back(Sy);
    return result;
}
/// @}

/**
 * @defgroup readMatrix readMatrix
 * @ingroup readMatrix
 * @{
 * @brief Reads matrix from ascii-formatted files generated by Matlab's 'save' function.
 * @param filename Name of text file to be read
 * @returns Eigen array with matrix from text file
 */
Mat readMatrix(std::string filename, int nr, int nc) {
    std::ifstream afile;
    afile.open(filename.c_str());
    Mat result(nr, nc);
    uint32 row = 0;
    uint32 col = 0;
    real number;
    while(afile >> number){
        result(row, col) = number;
        if(col == 255){
            row += 1;
            col = 0;
        } else {
            ++col;
        }
    }
    return result;
}

/// @}

// Overview page of Doxygen documentation has to go somewhere..:

/** @mainpage SKIZ Voronoi Diagram Tool and Matlab Bindings for VOISE Algorithm
 *
 * @section intro_sec Introduction
 *
 * The SKIZ operator algorithm, described by Sequeira and Preteux in [1], is an efficient way of calculating
 * and maintaining a Voronoi diagram in discrete 2D space. Unlike other, more popular algorithms such as Fortune's
 * Sweep, the SKIZ algorithm is dynamic so adding and removing seeds does not require recalculation of the entire graph.
 * Moreover, checking the bounds of a region R(s) and checking whether a pixel p belongs to a region R(s) is reduced
 * to evaluation of a small number of inequalities - a number which is bounded above by twice the number of neighbouring
 * seeds.
 *
 * The discrete nature of the SKIZ algorithm makes it well suited to image segmentation. The VOISE algorithm [2] relies
 * on a fast and dynamic method of recalculation of Voronoi diagrams upon addition and removal of seeds, so the two are
 * a natural fit. Although a standalone version of the SKIZ algorithm is included here (mostly for testing), the main
 * functionality is provided by the matlab bindings in pushVD, grabVD, addSeedToVD and removeSeedFromVD, which are
 * compiled into Matlab-readable MEX binaries and are tailored specifically for the code built and maintained by
 * P. Guio and N. Achilleos to aid faster image analysis through VOISE.
 *
 * @section install_sec Installation
 *
 * @subsection step1 Step 1: Installation
 *
 * Instructions: Cmake etc.
 *
 * @section references_sec References
 *
 * [1] R. E. Sequeira and F. J. Preteux. Discrete voronoi diagrams and the skiz
 * operator: a dynamic algorithm. IEEE Transactions on Pattern Analysis
 * and Machine Intelligence, 19(10):1165–1170, 1997. [doi: 10.1109/34.625128]
 *
 * [2] P. Guio and N. Achilleos. The voise algorithm: a versatile tool for automatic segmentation of astronomical images.
 * Monthly Notices of the Royal Astronomical Society, 398(3):1254–1262, 2009. [doi: 10.1111/j.1365-2966.2009.15218.x]
 */
